import OpenAI from "openai";
import { NextResponse } from "next/server";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

/* -------------------------------------------------------------------------- */
/*                         DATE NORMALIZATION (SERVER)                         */
/* -------------------------------------------------------------------------- */
function normalizeEventDate(value: string): string {
  const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/;

  if (isoRegex.test(value)) {
    return new Date(value).toISOString();
  }

  // Handle "tomorrow"
  if (value.toLowerCase().includes("tomorrow")) {
    const d = new Date();
    d.setUTCDate(d.getUTCDate() + 1);
    d.setUTCHours(18, 0, 0, 0);
    return d.toISOString();
  }

  throw new Error(`Invalid eventTimeISO generated by AI: ${value}`);
}

/* -------------------------------------------------------------------------- */
/*                                   ROUTE                                    */
/* -------------------------------------------------------------------------- */
export async function POST(req: Request) {
  const { prompt } = await req.json();

  const response = await openai.responses.create({
    model: "gpt-5.2",
    input: [
      {
        role: "system",
        content: `
You are an event planner AI.

MANDATORY RULES:
- eventTimeISO MUST be a valid ISO 8601 datetime string in UTC.
- NEVER return words like "tomorrow", "next week", or "Saturday".
- If the user says "tomorrow", compute the actual date.
- If no time is specified, default to 18:00 UTC.
- Example: 2026-02-08T18:00:00Z
- priceBNB MUST be a numeric string (e.g. "0.000001").
- maxAttendees MUST be a number (use 0 for unlimited).
`,
      },
      {
        role: "user",
        content: prompt,
      },
    ],
    tools: [
      {
        type: "function",
        name: "create_event_payload",
        description:
          "Generate structured event data compatible with a blockchain event booking smart contract",
        parameters: {
          type: "object",
          properties: {
            title: { type: "string" },
            description: { type: "string" },
            priceBNB: { type: "string" },
            eventTimeISO: { type: "string" },
            maxAttendees: { type: "number" },
            colorCode: { type: "string" },
          },
          required: [
            "title",
            "description",
            "priceBNB",
            "eventTimeISO",
            "maxAttendees",
            "colorCode",
          ],
          additionalProperties: false,
        },
        strict: true,
      },
    ],
  });

  // ðŸ” Extract tool call
  const toolCall = response.output?.find(
    (item) => item.type === "function_call",
  );

  if (!toolCall || toolCall.type !== "function_call") {
    return NextResponse.json(
      { error: "AI failed to generate event" },
      { status: 400 },
    );
  }

  const payload =
    typeof toolCall.arguments === "string"
      ? JSON.parse(toolCall.arguments)
      : toolCall.arguments;

  // ðŸ›  Normalize AI date BEFORE sending to frontend
  try {
    payload.eventTimeISO = normalizeEventDate(payload.eventTimeISO);
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 400 });
  }

  return NextResponse.json(payload);
}
